globals:
  - id: speed_measured
    type: float
    restore_value: no
    initial_value: "false"
    
  - id: position_measured_0
    type: float
    restore_value: no
    initial_value: "0.0"
  
  - id: position_measured_1
    type: float
    restore_value: no
    initial_value: "0.0"
  
  - id: time_measured_0
    type: int
    restore_value: no
    initial_value: "0"
    
  - id: time_measured_1
    type: int
    restore_value: no
    initial_value: "0"
    
  - id: measured_speed_first_value
    type: bool
    restore_value: no
    initial_value: "false"  
  
  - id: pinion_wheel_detected
    type: bool
    restore_value: no
    initial_value: "false"  

binary_sensor:
  - platform: template
    name: "${device_name_upper}.motor_state"
    id: ${stepper_motor_id}_motor_state
    lambda: |-
      if (id(${stepper_motor_id}_active).state) 
      {
        return true;
      }else 
      {
        // Motor is at target position
        return false;
      }   
    on_release:
      then:
        lambda: |-
          id(measured_speed_first_value) = false;
    on_press:
      then:
        
          
  - platform: gpio
    name: ${device_name_upper}.proximity_switch.pinion_wheel
    id: ${device_name}_proximity_switch_pinion_wheel
    pin: 
      number: ${sensor_proximity_switch_pinion_wheel_pin}
      mode:
        input: true
        pullup: true
    filters:
      - delayed_on: 50ms
    on_press:
      then:
        lambda: |-
          if (id(${stepper_motor_id}_motor_state).state)
          {
            id(pinion_wheel_detected) = true;
            if(!id(measured_speed_first_value))
            {
              id(position_measured_0) = id($stepper_motor_id).current_position;
              id(time_measured_0) = esp_timer_get_time();
              id(measured_speed_first_value) = true;
              id(speed_measured) = 0.0;
            }
            else
            {
              id(position_measured_1) = id($stepper_motor_id).current_position;
              id(time_measured_1) = esp_timer_get_time();
              
              // handle integer overflow
              if ( id(time_measured_1) < id(time_measured_0))
              {
                int max_integer = 2147483647;
                int old_diff = max_integer - id(time_measured_0);
                // shift old value into the negative value range
                id(time_measured_0) = -old_diff;
              }
              
              id(speed_measured) = (id(position_measured_1) - id(position_measured_0)) / ((id(time_measured_1) - id(time_measured_0)) / 1000000);
              id(time_measured_0) = id(time_measured_1);
              id(position_measured_0) = id(position_measured_1);
            }
          }
   
sensor:
  - platform: template
    name: "${stepper_motor_id_upper}.speed_measured_steps"
    id: ${stepper_motor_id}_speed_measured_steps
    state_class: "measurement"
    lambda: |-
      return id(speed_measured);
    unit_of_measurement: "steps/s"
    update_interval: ${sensor_update_interval_fast}
  
  - platform: template
    name: "${stepper_motor_id_upper}.speed_measured_deg"
    id: ${stepper_motor_id}_speed_measured_deg
    state_class: "measurement"
    lambda: |-
      return 60 * id(speed_measured) * (360.0 /id(full_turn_steps));
    unit_of_measurement: "deg/min"
    update_interval: ${sensor_update_interval_fast}
    
  - platform: template
    name: "${stepper_motor_id_upper}.speed_requested_steps"
    id: ${stepper_motor_id}_speed_requested_steps
    state_class: "measurement"
    lambda: |-
      if(id(${stepper_motor_id}_active).state)
      {
        return id(speed);
      }
      else
      {
        return 0.0;
      }
    unit_of_measurement: "steps/s"
    update_interval: ${sensor_update_interval_fast}

  - platform: template
    name: "${stepper_motor_id_upper}.speed_requested_deg"
    id: ${stepper_motor_id}_speed_requested_deg
    state_class: "measurement"
    lambda: |-
      if(id(${stepper_motor_id}_active).state)
      {
        return 60 * id(speed) * (360.0 / id(full_turn_steps)) ;
      }
      else
      {
        return 0.0;
      }
    unit_of_measurement: "deg/min"
    update_interval: ${sensor_update_interval_fast}