###################################################
# Settings via Substitutions
###################################################

substitutions:
  #general settings
  host_name: fabman-protohaus-bridge
  device_name: fabman_protohaus_bridge
  device_name_upper: fabman.protohaus.bridge
  add_mac_suffix: "true"
  status_led_pin: "GPIO13"
  status_led_interval_ok: 10s
  status_led_interval_booting: 3s
  settings_log_level: DEBUG
  settings_flash_write_interval: 1min
  activate_fast_connect: "false"
  
  # Fabman
  fabman_url: !secret fabman_access_url
  fabman_token: !secret fabman_access_token
  
  #I2C Bus
  i2c_bus_a_name: i2c_bus_a
  i2c_bus_a_sda: GPIO23
  i2c_bus_a_scl: GPIO22
  
  # SPI Bus
  spi_bus_a_name: spi_bus_a
  spi_bus_a_clk: GPIO14
  spi_bus_a_mosi: GPIO13
  spi_bus_a_miso: GPIO12
  spi_cs_pin: GPIO15
  
  # MQTT Settings
  mqtt_discovery: "false"
  
  # webserver
  web_server_ota_active: "true"

###################################################
# Basic setup 
###################################################

packages:
  common_status: !include common/status.yaml
  common_restart: !include common/restart.yaml
  common_spi_bus_a: !include common/spi_bus_a.yaml
  
esphome:
  name: ${host_name}
  platform: ESP32
  board: esp32dev
  name_add_mac_suffix: ${add_mac_suffix}

preferences:
  flash_write_interval: 1min
  
# Enable logging
logger:
  level: ${settings_log_level}
  
# enable ota updates
ota:
  password: !secret fabman_esphome_ota_pw

# Wifi Settings
wifi:
  networks:
  - ssid: !secret wifi_protohaus_ssid
    password: !secret wifi_protohaus_pw
  - ssid: !secret wifi_makeracademy_ssid
    password: !secret wifi_makeracademy_pw
  
  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "$device_name_upper AP"
    password: !secret fabman_esphome_fallback_ap_pw
  
  fast_connect: ${activate_fast_connect}

# Enable Home Assistant API
api:
  reboot_timeout: 15min
  password: !secret fabman_esphome_api_pw
  
captive_portal:

# Web server
web_server:
  port: !secret fabman_web_server_port
  auth:
    username: !secret fabman_web_server_user
    password: !secret fabman_web_server_password
  ota: ${web_server_ota_active}


# MQTT Broker Settings
#mqtt:
#  id: ${device_name}_mqtt_client
#  broker: !secret fabman_mqtt_broker_ip
#  username: !secret fabman_mqtt_usr
#  password: !secret fabman_mqtt_pw
#  discovery: ${mqtt_discovery}
#  port: !secret fabman_mqtt_port

rc522_spi:
  cs_pin: ${spi_cs_pin}
  on_tag:
    then:
      - http_request.get:
            #url: !lambda 'return ${fabman_url};'
            url: !lambda |-
                 std::string card_id = x;
                 card_id.erase(remove(card_id.begin(), card_id.end(), '-'), card_id.end());
                 std::string full_string = "https://fabman.io/api/v1/members?keyType=nfca&keyToken=" 
                                          + card_id 
                                          + "&embed=memberPackages"
                                          + "&embed=trainings"
                                          + "&embed=privileges"
                                          + "&embed=activePackages";
                 return full_string.c_str();
                 //return "https://fabman.io/api/v1/members?keyType=nfca&keyToken=04623A12664E80&embed=activePackages";
                 
            headers:
              Content-Type: application/json
              Authorization: '${fabman_token}'
            verify_ssl: false
            on_response:
              then:
                - logger.log:
                    format: 'Response status: %d'
                    args:
                      - status_code
                - lambda: |-
                    if(status_code == 200)
                    {
                      ESP_LOGD("main", "HTTP GET Successfull");
                      const char* payload_ = http_request_httprequestcomponent->get_string();
                      size_t size_ = strlen(payload_);
                      ESP_LOGD("main", "total payload size: %d bytes", (int)size_);
                      DynamicJsonDocument buffer(3000); //vorher mal 500 gewesen // we only extract [{"id": 00000000}] -> max. size: 48
                      StaticJsonDocument<3000> filter; // vorher mal 64 gewesen
                      filter[0]["id"] = true;
                      deserializeJson(buffer, payload_, DeserializationOption::Filter(filter));
                      JsonObject root = buffer[0];
                      int memberId = root["id"];  
                      id(member_id) = memberId;
                      ESP_LOGD("main", "The member ID is: %d", memberId);
                    }else
                    {
                      ESP_LOGD("main", "HTTP GET Request returned an error");
                    }  

  
sensor:
  - platform: wifi_signal
    name: "${device_name_upper}.wifi_signal"
    id: ${device_name}_wifi_signal
    update_interval: 60s
    

  
globals:
  - id: member_id                  
    type: int                           
    restore_value: no                   
    initial_value: "0"
  
  - id: number_of_admin_card_ids
    type: int
    restore_value: yes                   
    initial_value: "0"
    
  - id: admin_card_ids
    type: int[40]
    restore_value: yes                   
    initial_value: "{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}"
    
http_request:
  useragent: esphome/device
  timeout: 10s

text_sensor:
  - platform: template
    name: "Member ID"
    id: member_id_sensor
    icon: mdi:wan
    
button:
  - platform: template
    name: http_button
    id: http_button
    on_press:
      then:
        - lambda: |-
           long int card_id = 0;
           sscanf("04623A12664E80","%x",&card_id);
           //std::string hex_string = hex(card_id);
           
        - http_request.get:
            #url: !lambda 'return ${fabman_url};'
            url: !lambda |-
                 return "https://fabman.io/api/v1/members?keyType=nfca&keyToken=04623A12664E80&embed=activePackages";
                 
            headers:
              Content-Type: application/json
              Authorization: '${fabman_token}'
            verify_ssl: false
            on_response:
              then:
                - logger.log:
                    format: 'Response status: %d'
                    args:
                      - status_code
                - lambda: |-
                    if(status_code == 200)
                    {
                      ESP_LOGD("main", "HTTP GET Successfull");
                      const char* payload_ = http_request_httprequestcomponent->get_string();
                      size_t size_ = strlen(payload_);
                      ESP_LOGD("main", "total payload size: %d bytes", (int)size_);
                      DynamicJsonDocument buffer(500);  // we only extract [{"id": 00000000}] -> max. size: 48
                      StaticJsonDocument<64> filter;
                      filter[0]["id"] = true;
                      deserializeJson(buffer, payload_, DeserializationOption::Filter(filter));
                      JsonObject root = buffer[0];
                      int memberId = root["id"];  
                      id(member_id) = memberId;
                      ESP_LOGD("main", "The member ID is: %d", memberId);
                    }else
                    {
                      ESP_LOGD("main", "HTTP GET Request returned an error");
                    }                     
                    
                    
     # then:
        #- lambda: |-
        #    HTTPClient http;
        #    http.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", "XXXXXXXXXXXXXXXXXXXXXXXXXXXX");
        #    //http.Authorization = new AuthenticationHeaderValue("Bearer", "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX");
        #    //http.DefaultRequestHeaders.Add("Authorization", "Bearer " + "XXXXXXXXXXXXXXXXXXXXXXXXXX");
        #    //http.begin("https://fabman.io/api/v1/members?keyType=nfca&keyToken=04623A12664E80");
        #    //http.GET();
        #    //it.printf("The sensor value is: %s", http.getString().c_str());//
      
      #then:
      #  - lambda: |-
      #      http_request::HttpRequestSendAction<> http;
      #      http = new http_request::HttpRequestSendAction<>(http_request_httprequestcomponent);
      #      http->set_url("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX");
      #      http->set_method("GET");
      #      http->add_header("Content-Type", "application/json");
      #      http->add_header("Authorization", "Bearer XXXXXXXXXXXXXXXXXXXXXXXXXXX");
      #      http_request_httprequestresponsetrigger = new http_request::HttpRequestResponseTrigger();
      #      http->register_response_trigger(http_request_httprequestresponsetrigger);
      #      automation_28 = new Automation<int32_t>(http_request_httprequestresponsetrigger);
      #      lambdaaction_22 = new LambdaAction<int32_t>([=](int32_t status_code) -> void {
      #          ESP_LOGD("main", "Response status: %d", status_code);
      #      });